import os
import redis
import json
import uuid
import time
import sys
import requests
import subprocess
from functools import wraps
from opentelemetry import trace as trace_api
from opentelemetry.sdk.trace import TracerProvider
from .patching import patch_all
from . import state


def get_git_root():
    """Get the project's git root directory."""
    try:
        return (
            subprocess.check_output(["git", "rev-parse", "--show-toplevel"])
            .decode("ascii")
            .strip()
        )
    except Exception:
        return None


def get_git_sha():
    """Get the current git commit SHA."""
    try:
        return (
            subprocess.check_output(["git", "rev-parse", "HEAD"])
            .decode("ascii")
            .strip()
        )
    except Exception:
        return None


def init(
    workflow_name: str,
    service_name: str,
    redis_url: str = None,
    tags: dict = None,
    api_url: str = None,
):
    replay_execution_id = os.environ.get("TRACELAB_REPLAY_EXECUTION_ID")
    state._replay_mode = bool(replay_execution_id)

    if state._replay_mode:
        state._workflow_name = os.environ.get("TRACE_WORKFLOW_NAME")
    else:
        state._workflow_name = workflow_name or os.environ.get("TRACE_WORKFLOW_NAME")

    state._service_name = service_name or os.environ.get("TRACE_SERVICE_NAME")
    state._run_id = str(uuid.uuid4())
    state._step_idx = 0

    git_root = get_git_root()
    if git_root:
        # Store CWD and command path relative to the git root for portability
        state._cwd = os.path.relpath(os.getcwd(), git_root)
        script_path = os.path.abspath(sys.argv[0])
        script_rel_path = os.path.relpath(script_path, git_root)
        state._command = [script_rel_path] + sys.argv[1:]
    else:
        state._cwd = "."
        state._command = sys.argv

    state._git_sha = get_git_sha()
    # Default to localhost for local development, but use env var for containerized runs.
    redis_url = redis_url or os.environ.get(
        "TRACE_REDIS_URL", "redis://localhost:6379/0"
    )
    state._redis_client = redis.from_url(redis_url)

    # Check for replay mode
    state._recorded_events = []

    if state._replay_mode:
        print(
            f"--- TraceLab SDK running in REPLAY mode for execution: {replay_execution_id} ---"
        )
        api_url = api_url or os.environ.get("TRACELAB_API_URL", "http://localhost:8000")
        try:
            # Fetch the events from the original execution to be replayed
            url = f"{api_url}/api/v1/executions/{replay_execution_id}/events"
            response = requests.get(url)
            response.raise_for_status()
            state._recorded_events = response.json()
            print(
                f"Successfully fetched {len(state._recorded_events)} events for replay."
            )
        except Exception as e:
            print(
                f"ERROR: Could not fetch events for replay. Replay will not work. Error: {e}"
            )
            state._replay_mode = False  # Disable replay mode if we can't get events

    patch_all()


def trace(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        error = None
        try:
            result = func(*args, **kwargs)
            return result
        except Exception as e:
            error = str(e)
            raise
        finally:
            latency_ms = int((time.time() - start_time) * 1000)
            if state._redis_client:
                trace_event = {
                    "run_id": state._run_id,
                    "workflow_name": state._workflow_name,
                    "service_name": state._service_name,
                    "command": state._command,
                    "git_sha": state._git_sha,
                    "cwd": state._cwd,
                    "idx": state._step_idx,
                    "service": "custom",
                    "endpoint": func.__name__,
                    "request": {},  # Placeholder
                    "response": {},  # Placeholder
                    "latency_ms": latency_ms,
                    "error": error,
                }
                state._step_idx += 1
                try:
                    state._redis_client.xadd(
                        "trace.events", {"data": json.dumps(trace_event, default=str)}
                    )
                    print(f"Trace event sent to Redis: {trace_event['endpoint']}")
                except redis.exceptions.ConnectionError as e:
                    print(f"Could not send trace to Redis: {e}")

    return wrapper


def register_hook(name, func):
    # Placeholder for the hook registry
    pass


def shutdown():
    """
    Shuts down the tracer provider, flushing all buffered spans and sending a
    final completion event for the workflow.
    """
    # Send a final event to signal workflow completion
    if state._redis_client and state._run_id:
        final_event = {
            "run_id": state._run_id,
            "workflow_name": state._workflow_name,
            "service_name": state._service_name,
            "command": state._command,
            "git_sha": state._git_sha,
            "cwd": state._cwd,
            "status": "COMPLETED",
            "idx": state._step_idx,
            "service": "internal",
            "endpoint": "workflow.completion",
        }
        try:
            state._redis_client.xadd(
                "trace.events", {"data": json.dumps(final_event, default=str)}
            )
            print("Workflow completion event sent to Redis.")
        except redis.exceptions.ConnectionError as e:
            print(f"Could not send workflow completion event to Redis: {e}")

    provider = trace_api.get_tracer_provider()
    # The default provider is a NoOpTracerProvider, which doesn't have shutdown.
    if hasattr(provider, "shutdown"):
        provider.shutdown()
