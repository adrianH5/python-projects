import wrapt
import requests
import time
import json
import redis
from . import state


class MockResponse:
    """A mock response object to simulate requests.Response during replays."""

    def __init__(self, recorded_event):
        response_data = recorded_event.get("response", {})
        self.status_code = response_data.get("status_code", 200)
        self.headers = response_data.get("headers", {})

        body = response_data.get("body")
        if isinstance(body, str):
            self._content = body.encode("utf-8")
        elif body is not None:
            self._content = json.dumps(body).encode("utf-8")
        else:
            self._content = b""

        self.text = self._content.decode("utf-8")

        # Create a mock request object that can be attached to the response
        request_data = recorded_event.get("request", {})
        prepared_request = requests.Request(
            method=request_data.get("method", "GET"),
            url=request_data.get("url", ""),
            headers=request_data.get("headers", {}),
        ).prepare()
        self.request = prepared_request

    def json(self):
        return json.loads(self.text)

    def raise_for_status(self):
        if 400 <= self.status_code < 500:
            raise requests.exceptions.HTTPError(
                f"{self.status_code} Client Error", response=self
            )
        elif 500 <= self.status_code < 600:
            raise requests.exceptions.HTTPError(
                f"{self.status_code} Server Error", response=self
            )


def _capture_request(wrapped, instance, args, kwargs):
    start_time = time.time()
    response = None
    error = None
    req = None

    if state._replay_mode:
        try:
            # In replay mode, we fetch the recorded event for the current step
            recorded_event = state._recorded_events[state._step_idx]
            print(f"Replaying step {state._step_idx}: {recorded_event['endpoint']}")
            response = MockResponse(recorded_event)
            req = response.request
            error = recorded_event.get("error")

            if error:
                # If the original step had an error, we simulate it by raising an exception.
                raise requests.exceptions.RequestException(
                    error, response=response, request=req
                )

            # This will raise an HTTPError for 4xx/5xx status codes, just like a real request.
            response.raise_for_status()

        except IndexError:
            # This happens if the replay code makes more requests than the original recording.
            error = "Replay divergence: unexpected request."
            print(f"ERROR: {error}")
            response = MockResponse(
                {
                    "request": {"method": "UNKNOWN", "url": ""},
                    "response": {"status_code": 500, "body": {"error": error}},
                }
            )
            req = response.request
        except requests.exceptions.RequestException as e:
            # This catches the re-raised error from a failed original step.
            response = e.response
            req = e.request
            error = str(e)
    else:
        # Original record mode logic
        try:
            response = wrapped(*args, **kwargs)
            req = response.request
            response.raise_for_status()
        except requests.exceptions.RequestException as e:
            response = e.response
            req = e.request
            error = str(e)

    latency_ms = int((time.time() - start_time) * 1000)

    if state._redis_client and req:
        # Extract body safely
        req_body = kwargs.get("json") or kwargs.get("data")

        # Attempt to get response body
        try:
            res_body = (
                response.json()
                if response
                and response.headers.get("Content-Type") == "application/json"
                else (response.text if response else None)
            )
        except json.JSONDecodeError:
            res_body = response.text if response else None

        trace_event = {
            "run_id": state._run_id,
            "workflow_name": state._workflow_name,
            "service_name": state._service_name,
            "command": state._command,
            "git_sha": state._git_sha,
            "cwd": state._cwd,
            "idx": state._step_idx,
            "service": "http",
            "endpoint": f"{req.method} {req.url}",
            "request": {
                "method": req.method,
                "url": req.url,
                "headers": dict(req.headers),
                "body": req_body,
            },
            "response": {
                "status_code": response.status_code if response else None,
                "headers": dict(response.headers) if response else None,
                "body": res_body,
            },
            "latency_ms": latency_ms,
            "error": error,
        }
        state._step_idx += 1
        try:
            state._redis_client.xadd(
                "trace.events", {"data": json.dumps(trace_event, default=str)}
            )
            print(f"Trace event sent to Redis: {trace_event['endpoint']}")
        except redis.exceptions.ConnectionError as e:
            print(f"Could not send trace to Redis: {e}")

    if error:
        raise requests.exceptions.RequestException(
            error, response=response, request=req
        )

    return response


def patch_all():
    # Patch the core request method in the Session object. This will capture
    # all requests made by the requests library, including those made through
    # convenience functions like get() and post().
    wrapt.wrap_function_wrapper(
        "requests.sessions", "Session.request", _capture_request
    )
